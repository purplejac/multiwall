# lint:ignore:140chars lint:ignore:lookup_in_parameter
# @summary A short summary of the purpose of this defined type.
#
# A description of what this defined type does
#
# @example
#   multiwall::rule { 'namevar': }
#
# Parameters functionally copied directly from the puppetlabs/firewall module
# along with the descriptions, for ease of use.
#
# @param burst
#   Rate limiting burst value (per second) before limit checks apply.
#
# @param bytecode
#   Match using Linux Socket Filter. Expects a BPF program in decimal format.
#   This is the format generated by the nfbpf_compile utility.
#
# @param cgroup
#   Matches against the net_cls cgroup ID of the packet.
#
#   To negate add a space seperate `!` to the beginning of the string
#
# @param chain
#   Name of the chain the rule will be a part of, ensure the chain you choose exists within your set table.
#   Can be one of the built-in chains:
#
#   * INPUT
#   * FORWARD
#   * OUTPUT
#   * PREROUTING
#   * POSTROUTING
#
#   Or you can provide a user-based chain.
#   Defaults to 'INPUT'
#
# @param checksum_fill
#   Compute and fill missing packet checksums.
#
# @param pmtu
#   nftables does not support straight clamp_mss_to_pmtu, so whle the module will set a default,
#   we'll allow for an integer override here.
#
# @param clamp_mss_to_pmtu
#   Sets the clamp mss to pmtu flag.
#
# @param clusterip_clustermac
#   Used with the CLUSTERIP jump target.
#   Specify the ClusterIP MAC address. Has to be a link-layer multicast address.
#   This is IPv4 specific.
#
# @param clusterip_hash_init
#   Used with the CLUSTERIP jump target.
#   Specify the random seed used for hash initialization.
#   This is IPv4 specific.
#
# @param clusterip_hashmode
#   Used with the CLUSTERIP jump target.
#   Specify the hashing mode.
#   This is IPv4 specific.
#
# @param clusterip_local_node
#   Used with the CLUSTERIP jump target.
#   Specify the random seed used for hash initialization.
#   This is IPv4 specific.
#
# @param clusterip_new
#   Used with the CLUSTERIP jump target.
#   Create a new ClusterIP. You always have to set this on the first rule for a given ClusterIP.
#   This is IPv4 specific.
#
# @param clusterip_total_nodes
#   Used with the CLUSTERIP jump target.
#   Number of total nodes within this cluster.
#   This is IPv4 specific.
#
# @param condition
#   Match on boolean value (0/1) stored in /proc/net/nf_condition/name.
#
# @param connlimit_above
#   Connection limiting value for matched connections above n.
#
# @param connlimit_mask
#   Connection limiting by subnet mask for matched connections.
#   IPv4: 0-32
#   IPv6: 0-128
#
# @param connlimit_upto
#   Connection limiting value for matched connections below or equal to n.
#
# @param connmark
#   Match the Netfilter mark value associated with the packet, accepts a mark.
#   This value will be converted to hex if it is not already.
#   This value can be negated by adding a space seperated `!` to the beginning.
#
# @param ctdir
#   Matches a packet that is flowing in the specified direction using the
#   conntrack module. If this flag is not specified at all, matches packets
#   in both directions. Values can be:
#
#   * REPLY
#   * ORIGINAL
#
# @param ctexpire
#   Matches a packet based on lifetime remaining in seconds or range of seconds
#   using the conntrack module. For example:
#
#     ctexpire => '100'
#     ctexpire => '100:150'
#
# @param ctorigdst
#   The original destination address using the conntrack module. For example:
#
#       ctorigdst => '192.168.2.0/24'
#
#   You can also negate a mask by putting ! in front. For example:
#
#       ctorigdst => '! 192.168.2.0/24'
#
#   The ctorigdst can also be an IPv6 address if your provider supports it.
#
# @param ctorigdstport
#   The original destination port to match for this filter using the conntrack module.
#   For example:
#
#       ctorigdstport => '80'
#
#   You can also specify a port range: For example:
#
#       ctorigdstport => '80:81'
#
#   You can also negate a port by putting ! in front. For example:
#
#       ctorigdstport => '! 80'
#
# @param ctorigsrc
#   The original source address using the conntrack module. For example:
#
#       ctorigsrc => '192.168.2.0/24'
#
#   You can also negate a mask by putting ! in front. For example:
#
#       ctorigsrc => '! 192.168.2.0/24'
#
#   The ctorigsrc can also be an IPv6 address if your provider supports it.
#
# @param ctorigsrcport
#   The original source port to match for this filter using the conntrack module.
#   For example:
#
#       ctorigsrcport => '80'
#
#   You can also specify a port range: For example:
#
#       ctorigsrcport => '80:81'
#
#   You can also negate a port by putting ! in front. For example:
#
#       ctorigsrcport => '! 80'
# @param ctproto
#   The specific layer-4 protocol number to match for this rule using the
#   conntrack module.
#
# @param ctrepldst
#   The reply destination address using the conntrack module. For example:
#
#       ctrepldst => '192.168.2.0/24'
#
#   You can also negate a mask by putting ! in front. For example:
#
#       ctrepldst => '! 192.168.2.0/24'
#
#   The ctrepldst can also be an IPv6 address if your provider supports it.
#
# @param ctrepldstport
#   The reply destination port to match for this filter using the conntrack module.
#   For example:
#
#       ctrepldstport => '80'
#
#   You can also specify a port range: For example:
#
#       ctrepldstport => '80:81'
#
#   You can also negate a port by putting ! in front. For example:
#
#       ctrepldstport => '! 80'
#
# @param ctreplsrc
#   The reply source address using the conntrack module. For example:
#
#       ctreplsrc => '192.168.2.0/24'
#
#   You can also negate a mask by putting ! in front. For example:
#
#       ctreplsrc => '! 192.168.2.0/24'
#
#   The ctreplsrc can also be an IPv6 address if your provider supports it.
#
# @param ctreplsrcport
#   The reply source port to match for this filter using the conntrack module.
#   For example:
#
#       ctreplsrcport => '80'
#
#   You can also specify a port range: For example:
#
#       ctreplsrcport => '80:81'
#
#   You can also negate a port by putting ! in front. For example:
#
#       ctreplsrcport => '! 80'
#
# @param ctstate
#   Matches a packet based on its state in the firewall stateful inspection
#   table, using the conntrack module. Values can be:
#
#   * INVALID
#   * ESTABLISHED
#   * NEW
#   * RELATED
#   * UNTRACKED
#   * SNAT
#   * DNAT
#
#   Can be passed either as a single String or as an Array, if passed as an array values should be passed in order:
#
#       ctstate => 'INVALID'
#       ctstate => ['INVALID', 'ESTABLISHED']
#
#   Values can be negated by adding a '!'.
#   If you wish to negate multiple states at once, then place a ! at the start of the first array
#   variable. For example:
#
#   ctstate => ['! INVALID', 'ESTABLISHED']
#
#   Note:
#     This will negate all passed states, it is not possible to negate a single one of the array.
#     In order to maintain compatibility it is also possible to negate all values given in the array to achieve the same behaviour.
#
# @param ctstatus
#   Matches a packet based on its status using the conntrack module. Values can be:
#
#   * EXPECTED
#   * SEEN_REPLY
#   * ASSURED
#   * CONFIRMED
#   * NONE
#
#   Can be passed either as a single String or as an Array:
#
#     ctstatus => 'EXPECTED'
#     ctstatus => ['EXPECTED', 'CONFIRMED']
#
#   Values can be negated by adding a '!'.
#   If you wish to negate multiple states at once, then place a ! at the start of the first array
#   variable. For example:
#
#     ctstatus => ['! EXPECTED', 'CONFIRMED']
#
#   Note:#{' '}
#     This will negate all passed states, it is not possible to negate a single one of the array.
#     In order to maintain compatibility it is also possible to negate all values given in the array to achieve the same behaviour.
#
# @param date_start
#   Only match during the given time, which must be in ISO 8601 "T" notation.
#   The possible time range is 1970-01-01T00:00:00 to 2038-01-19T04:17:07
#
# @param date_stop
#   Only match during the given time, which must be in ISO 8601 "T" notation.
#   The possible time range is 1970-01-01T00:00:00 to 2038-01-19T04:17:07
#
# @param destination
#   The destination address to match. For example:
#
#       destination => '192.168.1.0/24'
#
#   You can also negate a mask by putting ! in front. For example:
#
#       destination  => '! 192.168.2.0/24'
#
#   The destination can also be an IPv6 address if your provider supports it.
#
# @param dport
#   The source port to match for this filter (if the protocol supports
#   ports). Will accept a single element or an array.
#
#   For some firewall providers you can pass a range of ports in the format:
#
#       dport => '1:1024'
#
#   This would cover ports 1 to 1024.
#
#   You can also negate a port by putting ! in front. For example:
#
#       dport => '! 54'
#
#   If you wish to negate multiple ports at once, then place a ! at the start of the first array
#   variable. For example:
#
#       dport => ['! 54','23']
#
#   Note:
#     This will negate all passed ports, it is not possible to negate a single one of the array.
#     In order to maintain compatibility it is also possible to negate all values given in the array to achieve the same behaviour.
#
# @param dst_cc
#   dst attribute for the module geoip
#
# @param dst_range
#   The destination IP range. For example:
#
#       dst_range => '192.168.1.1-192.168.1.10'
#
#   You can also negate the range by putting ! in front. For example:
#
#       dst_range => '! 192.168.1.1-192.168.1.10'
#
#   The destination IP range must be in 'IP1-IP2' format.
#
# @param dst_type
#   The destination address type. For example:
#
#       dst_type => ['LOCAL']
#
#   Can be one of:
#
#   * UNSPEC - an unspecified address
#   * UNICAST - a unicast address
#   * LOCAL - a local address
#   * BROADCAST - a broadcast address
#   * ANYCAST - an anycast packet
#   * MULTICAST - a multicast address
#   * BLACKHOLE - a blackhole address
#   * UNREACHABLE - an unreachable address
#   * PROHIBIT - a prohibited address
#   * THROW - undocumented
#   * NAT - undocumented
#   * XRESOLVE - undocumented
#
#   In addition, it accepts '--limit-iface-in' and '--limit-iface-out' flags, specified as:
#
#       dst_type => ['LOCAL --limit-iface-in']
#
#   Each value can be negated seperately using '!':
#
#       dst_type => ['! UNICAST', '! LOCAL']
#
#   Will accept a single element or an array.
#
# @param ensure
#   Whether this rule should be present or absent on the target system.
#
# Default value: present
#
# @param gateway
#   The TEE target will clone a packet and redirect this clone to another
#   machine on the local network segment.
#   Gateway is the target host's IP.
#
# @param gid
#   GID or Group owner matching rule.  Accepts a single argument
#   only, as iptables does not accept multiple gid in a single
#   statement.
#   To negate add a space seperated '!' in front of the value.
#
# @param goto
#   The value for the iptables --goto parameter. Normal values are:
#
#   * QUEUE
#   * RETURN
#   * DNAT
#   * SNAT
#   * LOG
#   * MASQUERADE
#   * REDIRECT
#   * MARK
#
#   But any valid chain name is allowed.
#
# @param hashlimit_above
#   Match if the rate is above amount/quantum.
#   This parameter or `hashlimit_upto` and `hashlimit_name` are required when setting any other hashlimit values.
#   Allowed forms are '40','40/sec','40/min','40/hour','40/day'.
#
# @param hashlimit_burst
#   Maximum initial number of packets to match: this number gets recharged by one every time the limit specified above is not reached, up to this number; the default is 5.
#   When byte-based rate matching is requested, this option specifies the amount of bytes that can exceed the given rate.
#   This option should be used with caution -- if the entry expires, the burst value is reset too.
#
# @param hashlimit_dstmask
#   When --hashlimit-mode srcip is used, all destination addresses encountered will be grouped according to the given prefix length
#   and the so-created subnet will be subject to hashlimit.
#   Prefix must be between (inclusive) 0 and 32.
#   Note that --hashlimit-dstmask 0 is basically doing the same thing as not specifying srcip for --hashlimit-mode, but is technically more expensive.
#
# @param hashlimit_htable_expire
#   After how many milliseconds do hash entries expire.
#
# @param hashlimit_htable_gcinterval
#   How many milliseconds between garbage collection intervals.
#
# @param hashlimit_htable_max
#   Maximum entries in the hash.
#
# @param hashlimit_htable_size
#   The number of buckets of the hash table
#
# @param hashlimit_mode
#   A comma-separated list of objects to take into consideration.
#   If no --hashlimit-mode option is given, hashlimit acts like limit, but at the expensive of doing the hash housekeeping.
#   Allowed values are: srcip, srcport, dstip, dstport
#
# @param hashlimit_name
#   The name for the /proc/net/ipt_hashlimit/foo entry.
#   This parameter and either `hashlimit_upto` or `hashlimit_above` are required when setting any other hashlimit values.
#
# @param hashlimit_srcmask
#   When --hashlimit-mode srcip is used, all source addresses encountered will be grouped according to the given prefix length
#   and the so-created subnet will be subject to hashlimit.
#   Prefix must be between (inclusive) 0 and 32.
#   Note that --hashlimit-srcmask 0 is basically doing the same thing as not specifying srcip for --hashlimit-mode, but is technically more expensive.
#
# @param hashlimit_upto
#   Match if the rate is below or equal to amount/quantum. It is specified either as a number, with an optional time quantum suffix (the default is 3/hour), or as amountb/second (number of bytes per second).
#   This parameter or `hashlimit_above` and `hashlimit_name` are required when setting any other hashlimit values.
#   Allowed forms are '40','40/sec','40/min','40/hour','40/day'.
#
# @param helper
#   Invoke the nf_conntrack_xxx helper module for this packet.
#
# @param hop_limit
#   Hop limiting value for matched packets.
#   To negate add a space seperated `!` the the beginning of the value
#   This is IPv6 specific.
#
# @param icmp
#   When matching ICMP packets, this is the type of ICMP packet to match.
#
#   A value of "any" is not supported. To achieve this behaviour the
#   parameter should simply be omitted or undefined.
#   An array of values is also not supported. To match against multiple ICMP
#   types, please use separate rules for each ICMP type.
#
# @param iniface
#   Input interface to filter on.  Supports interface alias like eth0:0.
#   To negate the match try this:
#
#         iniface => '! lo',
#
# @param ipsec_dir
#   Sets the ipsec policy direction
#
# @param ipsec_policy
#   Sets the ipsec policy type. May take a combination of arguments for any flags that can be passed to `--pol ipsec` such as: `--strict`, `--reqid 100`, `--next`, `--proto esp`, etc.
#
# @param ipset
#   Matches against the specified ipset list.
#   Requires ipset kernel module. Will accept a single element or an array.
#   The value is the name of the denylist, followed by a space, and then
#   'src' and/or 'dst' separated by a comma.
#   For example: 'denylist src,dst'
#   To negate simply place a space seperated `!` at the beginning of a value.
#   Values can de negated independently.
#
# @param ipvs
#   Match using Linux Socket Filter. Expects a BPF program in decimal format.
#   This is the format generated by the nfbpf_compile utility.
#
# @param isfirstfrag
#   Matches if the packet is the first fragment.
#   Specific to IPv6.
#
# @param isfragment
#   Set to true to match tcp fragments (requires proto to be set to tcp)
#
# @param ishasmorefrags
#   Matches if the packet has it's 'more fragments' bit set.
#   Specific to IPv6.
#
# @param islastfrag
#   Matches if the packet is the last fragment.
#   Specific to IPv6.
#
# @param jump
#   This value for the iptables --jump parameter and the action to perform on a match. Common values are:
#
#   * ACCEPT - the packet is accepted
#   * REJECT - the packet is rejected with a suitable ICMP response
#   * DROP - the packet is dropped
#
#   But can also be one of the following:
#
#   * QUEUE
#   * RETURN
#   * DNAT
#   * SNAT
#   * LOG
#   * NFLOG
#   * NETMAP
#   * MASQUERADE
#   * REDIRECT
#   * MARK
#   * CT
#
#   And any valid chain name is also allowed.
#
#   If you specify no value it will simply match the rule but perform no action.
#
# @param kernel_timezone
#   Use the kernel timezone instead of UTC to determine whether a packet meets the time regulations.
#
# @param length
#   Sets the length of layer-3 payload to match.
#
#   Example values are: '500', '5:400'
#
# @param limit
#   Rate limiting value for matched packets. The format is:
#   rate/[/second/|/minute|/hour|/day]
#
#   Example values are: '50/sec', '40/min', '30/hour', '10/day'."
#
# @param line
#   A read only attribute containing the full rule, used when deleting and when applying firewallchain purge attributes.
#
# @param log_ip_options
#   When combined with jump => "LOG" logging of the TCP IP/IPv6 packet header.
#
# @param log_level
#   When combined with jump => "LOG" specifies the system log level to log to.
#
#   Note: log level 4/warn is the default setting and as such it is not returned by iptables-save.
#   As a result, explicitly setting `log_level` to this can result in idempotency errors.
#
# @param log_prefix
#   When combined with jump => "LOG" specifies the log prefix to use when logging.
#
# @param log_tcp_options
#   When combined with jump => "LOG" logging of the TCP packet header.
#
# @param log_tcp_sequence
#   When combined with jump => "LOG" enables logging of the TCP sequence numbers.
#
# @param log_uid
#   When combined with jump => "LOG" specifies the uid of the process making the connection.
#
# @param mac_source
#   MAC Source
#
# @param mask
#   Recent module; sets the mask to use when `recent` is enabled.
#   The recent module defaults this to `255.255.255.255` when recent is set
#
# @param match_mark
#   Match the Netfilter mark value associated with the packet, accepts a mark.
#   This value will be converted to hex if it is not already.
#   This value can be negated by adding a space seperated `!` to the beginning.
#
# @param month_days
#   Only match on the given days of the month. Possible values are 1 to 31.
#   Note that specifying 31 will of course not match on months which do not have a 31st day;
#   the same goes for 28-day or 29-day February.
#
#   Can be passed either as a single value or an array of values:
#     month_days => 5,
#     month_days => [5, 9, 23],
#
# @param mss
#   Match a given TCP MSS value or range.
#   This value can be negated by adding a space seperated `!` to the beginning.
#
# @param nflog_group
#   Used with the jump target NFLOG.
#   The netlink group (0 - 2^16-1) to which packets are (only applicable
#   for nfnetlink_log). Defaults to 0.
#
# @param nflog_prefix
#   Used with the jump target NFLOG.
#   A prefix string to include in the log message, up to 64 characters long,
#   useful for distinguishing messages in the logs.
#
# @param nflog_range
#   Used with the jump target NFLOG.
#   This has never worked, use nflog_size instead.
#
# @param nflog_size
#   Used with the jump target NFLOG.
#   The number of bytes to be copied to userspace (only applicable for nfnetlink_log).
#   nfnetlink_log instances may specify their own size, this option overrides it.
#
# @param nflog_threshold
#   Used with the jump target NFLOG.
#   Number of packets to queue inside the kernel before sending them to userspace
#   (only applicable for nfnetlink_log). Higher values result in less overhead
#   per packet, but increase delay until the packets reach userspace. Defaults to 1.
#
# @param notrack
#   Invoke the disable connection tracking for this packet.
#   This parameter can be used with iptables version >= 1.8.3
#
# @param outiface
#   Output interface to filter on.  Supports interface alias like eth0:0.
#   To negate the match try this:
#
#         outiface => '! lo',
#
# @param physdev_in
#   Match if the packet is entering a bridge from the given interface.
#   To negate the match try this:
#
#       physdev_in => '! lo',
#
# @param physdev_is_bridged
#   Match if the packet is transversing a bridge.
#
# @param physdev_is_in
#   Matches if the packet has entered through a bridge interface.
#
# @param physdev_is_out
#   Matches if the packet will leave through a bridge interface.
#
# @param physdev_out
#   Match if the packet is leaving a bridge via the given interface.
#   To negate the match try this:
#
#       physdev_out => '! lo',
#
# @param pkttype
#   Sets the packet type to match.
#
# @param proto
#   The specific protocol to match for this rule.
#
# @param protocol
#   The protocol used to set the rule, it's allowed values have been expanded to bring it closer to its `firewallchain` counterpart.
#   Defaults to `IPv4`
#
#   Noted: this was previously defined as `provider`, however the resource_api does not allow this to be used as an attribute title.
#
# @param action
#   This parameter is largely deprecated but exists to enable support for older versions of puppetlabs/firewall. 
#   for any newly written rules, an implementer should look to use the 'jump' parameter instead.
#
#   Default Value: undef
#
# @param target_firewall
#   The firewall being implemented through the use of the multiwall module.
#   while the module is created to interpret the input format of puppetlabs/firewall
#   it is intended to output through other modules. At creation, the only two
#   supported options are 'iptables' and 'nftables' but there's potential for
#   further additions.
#
#   Default Value: 'nftables'
#
# @param queue_bypass
#   Allow packets to bypass :queue_num if userspace process is not listening
#
# @param queue_num
#   Used with NFQUEUE jump target.
#   What queue number to send packets to
#
# @param random
#   When using a jump value of "MASQUERADE", "DNAT", "REDIRECT", or "SNAT" this boolean will enable randomized port mapping.
#
# @param random_fully
#   When using a jump value of "MASQUERADE", "DNAT", "REDIRECT", or "SNAT" this boolean will enable fully randomized port mapping.
#
# @param rdest
#   Recent module; add the destination IP address to the list.
#   Mutually exclusive with `rsource`
#   Must be boolean true.
#
# @param reap
#   Recent module; can only be used in conjunction with the `rseconds`
#   attribute. When used, this will cause entries older than 'seconds' to be
#   purged.  Must be boolean true.
#
# @param recent
#   Enable the recent module. Takes as an argument one of set, update,
#   rcheck or remove. For example:
#
#     ```
#     # If anyone's appeared on the 'badguy' blacklist within
#     #  the last 60 seconds, drop their traffic, and update the timestamp.
#     firewall { '100 Drop badguy traffic':
#       recent   => 'update',
#       rseconds => 60,
#       rsource  => true,
#       rname    => 'badguy',
#       jump     => 'DROP',
#       chain    => 'FORWARD',
#     }
#     ```    ```
#     # No-one should be sending us traffic on eth0 from the
#     #  localhost, Blacklist them
#     firewall { '101 blacklist strange traffic':
#       recent      => 'set',
#       rsource     => true,
#       rname       => 'badguy',
#       destination => '127.0.0.0/8',
#       iniface     => 'eth0',
#       jump        => 'DROP',
#       chain       => 'FORWARD',
#     }
#     ```
#
# @param reject
#   When combined with jump => "REJECT" you can specify a different icmp response to be sent back to the packet sender.
#   Valid values differ depending on if the protocol is `IPv4` or `IPv6`.
#   IPv4 allows: icmp-net-unreachable, icmp-host-unreachable, icmp-port-unreachable, icmp-proto-unreachable, icmp-net-prohibited,
#   icmp-host-prohibited, or icmp-admin-prohibited.
#   IPv6 allows: icmp6-no-route, no-route, icmp6-adm-prohibited, adm-prohibited, icmp6-addr-unreachable, addr-unreach, or icmp6-port-unreachable.
#
# @param rhitcount
#   Recent module; used in conjunction with `recent => 'update'` or `recent
#   => 'rcheck'. When used, this will narrow the match to only happen when
#   the address is in the list and packets had been received greater than or
#   equal to the given value.
#
# @param rname
#   Recent module; The name of the list.
#   The recent module defaults this to `DEFAULT` when recent is set
#
# @param rpfilter
#   Enable the rpfilter module.
#
# @param rseconds
#   Recent module; used in conjunction with one of `recent => 'rcheck'` or
#   `recent => 'update'`. When used, this will narrow the match to only
#   happen when the address is in the list and was seen within the last given
#   number of seconds.
#
# @param rsource
#   Recent module; add the source IP address to the list.
#   Mutually exclusive with `rdest`
#   The recent module defaults this behaviour to true when recent is set.
#
# @param rttl
#   Recent module; may only be used in conjunction with one of `recent =>
#   'rcheck'` or `recent => 'update'`. When used, this will narrow the match
#   to only happen when the address is in the list and the TTL of the current
#   packet matches that of the packet which hit the `recent => 'set'` rule.
#   This may be useful if you have problems with people faking their source
#   address in order to DoS you via this module by disallowing others access
#   to your site by sending bogus packets to you.  Must be boolean true.
#
# @param set_dscp
#   Set DSCP Markings.
#
# @param set_dscp_class
#   This sets the DSCP field according to a predefined DiffServ class.
#
# @param set_mark
#   Set the Netfilter mark value associated with the packet.  Accepts either of mark/mask or mark.
#   These will be converted to hex if they are not already.
#
# @param set_mss
#   Sets the TCP MSS value for packets.
#
# @param socket
#   If true, matches if an open socket can be found by doing a coket lookup
#   on the packet.
#
# @param source
#   The source address. For example:
#
#       source => '192.168.2.0/24'
#
#   You can also negate a mask by putting ! in front. For example:
#
#       source => '! 192.168.2.0/24'
#
#   The source can also be an IPv6 address if your provider supports it.
#
# @param sport
#   The source port to match for this filter (if the protocol supports
#   ports). Will accept a single element or an array.
#
#   For some firewall providers you can pass a range of ports in the format:
#
#       sport => '1:1024'
#
#   This would cover ports 1 to 1024.
#
#   You can also negate a port by putting ! in front. For example:
#
#       sport => '! 54'
#
#   If you wish to negate multiple ports at once, then place a ! at the start of the first array
#   variable. For example:
#
#       sport => ['! 54','23']
#
#   Note:
#     This will negate all passed ports, it is not possible to negate a single one of the array.
#     In order to maintain compatibility it is also possible to negate all values given in the array to achieve the same behaviour.
#
# @param src_cc
#   src attribute for the module geoip
#
# @param src_range
#   The source IP range. For example:
#
#       src_range => '192.168.1.1-192.168.1.10'
#
#   You can also negate the range by apending a `!`` to the front. For example:
#
#       src_range => '! 192.168.1.1-192.168.1.10'
#
#   The source IP range must be in 'IP1-IP2' format.
#
# @param src_type
#   The source address type. For example:
#
#       src_type => 'LOCAL'
#
#   Can be one of:
#
#   * UNSPEC - an unspecified address
#   * UNICAST - a unicast address
#   * LOCAL - a local address
#   * BROADCAST - a broadcast address
#   * ANYCAST - an anycast packet
#   * MULTICAST - a multicast address
#   * BLACKHOLE - a blackhole address
#   * UNREACHABLE - an unreachable address
#   * PROHIBIT - a prohibited address
#   * THROW - undocumented
#   * NAT - undocumented
#   * XRESOLVE - undocumented
#
#   In addition, it accepts '--limit-iface-in' and '--limit-iface-out' flags, specified as:
#
#       src_type => ['LOCAL --limit-iface-in']
#
#   It can also be negated using '!':
#
#       src_type => ['! LOCAL']
#
#   Will accept a single element or an array. Each element of the array should be negated seperately.
#
# @param stat_every
#   Match one packet every nth packet. Requires `stat_mode => 'nth'`
#
# @param stat_mode
#   Set the matching mode for statistic matching.
#
# @param stat_packet
#   Set the initial counter value for the nth mode. Must be between 0 and the value of `stat_every`.
#   Defaults to 0. Requires `stat_mode => 'nth'`
#
# @param stat_probability
#   Set the probability from 0 to 1 for a packet to be randomly matched. It works only with `stat_mode => 'random'`.
#
# @param state
#   Matches a packet based on its state in the firewall stateful inspection
#   table. Values can be:
#
#   * INVALID
#   * ESTABLISHED
#   * NEW
#   * RELATED
#   * UNTRACKED
#   * SNAT
#   * DNAT
#
#   Can be passed either as a single String or as an Array:
#
#       state => 'INVALID'
#       state => ['INVALID', 'ESTABLISHED']
#
#   Values can be negated by adding a '!'.
#   If you wish to negate multiple states at once, then place a ! at the start of the first array
#   variable. For example:
#
#       state => ['! INVALID', 'ESTABLISHED']
#
#   Note:
#     This will negate all passed states, it is not possible to negate a single one of the array.
#     In order to maintain compatibility it is also possible to negate all values given in the array to achieve the same behaviour.
#
# @param string
#   String matching feature. Matches the packet against the pattern
#   given as an argument.
#   To negate, add a space seperated `!` to the beginning of the string.
#
# @param string_algo
#   String matching feature, pattern matching strategy.
#
# @param string_from
#   String matching feature, offset from which we start looking for any matching.
#
# @param string_hex
#   String matching feature. Matches the packet against the pattern
#   given as an argument.
#   To negate, add a space seperated `!` to the beginning of the string.
#
# @param string_to
#   String matching feature, offset up to which we should scan.
#
# @param table
#   The table the rule will exist in.
#   Valid options are:
#
#   * nat
#   * mangle
#   * filter
#   * raw
#   * rawpost
#
#   Defaults to 'filter'
#
# @param tcp_flags
#   Match when the TCP flags are as specified.
#   Is a string with a list of comma-separated flag names for the mask,
#   then a space, then a comma-separated list of flags that should be set.
#   The flags are: FIN SYN RST PSH ACK URG ALL NONE
#   Note that you specify them in the order that iptables --list-rules
#   would list them to avoid having puppet think you changed the flags.
#
#   Example: FIN,SYN,RST,ACK SYN matches packets with the SYN bit set and the
#   ACK,RST and FIN bits cleared. Such packets are used to request
#   TCP  connection initiation.
#   Can be negated by placing ! in front, i.e.
#     ! FIN,SYN,RST,ACK SYN
#
# @param tcp_option
#   Match when the TCP option is present or absent.
#   Given as a single TCP option, optionally prefixed with '! ' to match
#   on absence instead.  Only one TCP option can be matched in a given rule.
#   TCP option numbers are an eight-bit field, so valid option numbers range
#   from 0-255.
#
# @param time_contiguous
#   When time_stop is smaller than time_start value, match this as a single time period instead distinct intervals.
#
# @param time_start
#   Only match during the given daytime. The possible time range is 00:00:00 to 23:59:59.
#   Leading zeroes are allowed (e.g. "06:03") and correctly interpreted as base-10.
#
# @param time_stop
#   Only match during the given daytime. The possible time range is 00:00:00 to 23:59:59.
#   Leading zeroes are allowed (e.g. "06:03") and correctly interpreted as base-10.
#
# @param to
#   For NETMAP this will replace the destination IP
#
# @param todest
#   When using jump => "DNAT" you can specify the new destination address using this paramter.
#   Can specify a single new destination IP address or an inclusive range of IP addresses.
#   Optionally a port or a port range with a possible follow up baseport can be provided.
#   Input structure: [ipaddr[-ipaddr]][:port[-port[/baseport]]]
#
# @param toports
#   For REDIRECT/MASQUERADE this is the port that will replace the destination/source port.
#   Can specify a single new port or an inclusive range of ports.
#
# @param tosource
#   When using jump => "SNAT" you can specify the new source address using this paramter.
#   Can specify a single new destination IP address or an inclusive range of IP addresses.
#   Input structure: [ipaddr[-ipaddr]][:port[-port]]
#
# @param u32
#   Enable the u32 module. Takes as an argument one of set, update,
#   rcheck or remove. For example:
#     firewall { '032 u32 test':
#       ensure   => present,
#       table    => 'mangle',
#       chain    => 'PREROUTING',
#       u32      => '0x4&0x1fff=0x0&&0x0&0xf000000=0x5000000',
#       jump     => 'DROP',
#     }
#
# @param uid
#   UID or Username owner matching rule.  Accepts a single argument
#   only, as iptables does not accept multiple uid in a single
#   statement.
#   To negate add a space seperated '!' in front of the value.
#
# @param week_days
#   Only match on the given weekdays.
#
#   Can be passed either as a single value or an array of values:
#     week_days => 'Mon',
#     week_days => ['Mon', 'Tue', 'Wed'],
#
# @param zone
#   Assign this packet to zone id and only have lookups done in that zone.
#
define multiwall::rule (
  Enum[present, absent, 'present', 'absent']                                                                                                                                                      $ensure,
  String[1]                                                                                                                                                                                       $chain,
  Enum['iptables', 'ip6tables', 'IPv4', 'IPv6', 'inet']                                                                                                                                           $protocol = 'IPv4',
  Enum['nat', 'mangle', 'filter', 'raw', 'rawpost', 'broute', 'security']                                                                                                                         $table = 'filter',
  Enum['iptables', 'nftables']                                                                                                                                                                    $target_firewall = lookup('multiwall::target_firewall', { default_value => 'nftables' }), 
  Optional[Enum['accept','reject','drop']]                                                                                                                                                        $action = undef,
  String                                                                                                                                                                                          $jump   = $action,
  Optional[Integer[1]]                                                                                                                                                                            $burst = undef,
  Optional[String[1]]                                                                                                                                                                             $bytecode = undef,
  Optional[String[1]]                                                                                                                                                                             $cgroup = undef,
  Optional[Boolean]                                                                                                                                                                               $checksum_fill = undef,
  Optional[Integer]                                                                                                                                                                               $pmtu = undef,
  Optional[Boolean]                                                                                                                                                                               $clamp_mss_to_pmtu = undef,
  Optional[Pattern[/^([0-9a-fA-F]{2}[:]){5}([0-9a-fA-F]{2})$/]]                                                                                                                                   $clusterip_clustermac = undef,
  Optional[String[1]]                                                                                                                                                                             $clusterip_hash_init = undef,
  Optional[Enum['sourceip', 'sourceip-sourceport', 'sourceip-sourceport-destport']]                                                                                                               $clusterip_hashmode = undef,
  Optional[Integer[1]]                                                                                                                                                                            $clusterip_local_node = undef,
  Optional[Boolean]                                                                                                                                                                               $clusterip_new = undef,
  Optional[Integer[1]]                                                                                                                                                                            $clusterip_total_nodes = undef,
  Optional[String[1]]                                                                                                                                                                             $condition = undef,
  Optional[Integer]                                                                                                                                                                               $connlimit_above = undef,
  Optional[Integer[0,128]]                                                                                                                                                                        $connlimit_mask = undef,
  Optional[Integer]                                                                                                                                                                               $connlimit_upto = undef,
  Optional[Pattern[/^(?:!\s)?[a-fA-F0-9x]+$/]]                                                                                                                                                    $connmark = undef,
  Optional[Enum['REPLY', 'ORIGINAL']]                                                                                                                                                             $ctdir = undef,
  Optional[Pattern[/^(?:!\s)?\d+(?:\:\d+)?$/]]                                                                                                                                                    $ctexpire = undef,
  Optional[String[1]]                                                                                                                                                                             $ctorigdst = undef,
  Optional[Pattern[/^(?:!\s)?\d+(?:\:\d+)?$/]]                                                                                                                                                    $ctorigdstport = undef,
  Optional[String[1]]                                                                                                                                                                             $ctorigsrc = undef,
  Optional[Pattern[/^(?:!\s)?\d+(?:\:\d+)?$/]]                                                                                                                                                    $ctorigsrcport = undef,
  Optional[Variant[Pattern[/^(?:!\s)?\d+$/],Integer]]                                                                                                                                             $ctproto = undef,
  Optional[String[1]]                                                                                                                                                                             $ctrepldst = undef,
  Optional[Pattern[/^(?:!\s)?\d+(?:\:\d+)?$/]]                                                                                                                                                    $ctrepldstport = undef,
  Optional[String[1]]                                                                                                                                                                             $ctreplsrc = undef,
  Optional[Pattern[/^(?:!\s)?\d+(?:\:\d+)?$/]]                                                                                                                                                    $ctreplsrcport = undef,
  Optional[Variant[Pattern[/^(?:!\s)?(?:INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED|SNAT|DNAT)$/],
    Array[Pattern[/^(?:!\s)?(?:INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED|SNAT|DNAT)$/]]]
  ]                                                                                                                                                                                               $ctstate = undef,
  Optional[Variant[Pattern[/^(?:!\s)?(?:EXPECTED|SEEN_REPLY|ASSURED|CONFIRMED|NONE)$/],
    Array[Pattern[/^(?:!\s)?(?:EXPECTED|SEEN_REPLY|ASSURED|CONFIRMED|NONE)$/]]]
  ]                                                                                                                                                                                               $ctstatus = undef,
  Optional[Pattern[/^[0-9]{4}\-(?:0[0-9]|1[0-2])\-(?:[0-2][0-9]|3[0-1])T(?:[0-1][0-9]|2[0-3])\:[0-5][0-9]\:[0-5][0-9]$/]]                                                                         $date_start = undef,
  Optional[Pattern[/^[0-9]{4}\-(?:0[0-9]|1[0-2])\-(?:[0-2][0-9]|3[0-1])T(?:[0-1][0-9]|2[0-3])\:[0-5][0-9]\:[0-5][0-9]$/]]                                                                         $date_stop = undef,
  Optional[String[1]]                                                                                                                                                                             $destination = undef,
  Optional[Variant[Array[Variant[Pattern[/^(?:!\s)?\d+(?:(?:\:|-)\d+)?$/],Integer]],
      Pattern[/^(?:!\s)?\d+(?:(?:\:|-)\d+)?$/],
    Integer]
  ]                                                                                                                                                                                               $dport = undef,
  Optional[Pattern[/^[A-Z]{2}(,[A-Z]{2})*$/]]                                                                                                                                                     $dst_cc = undef,
  Optional[String[1]]                                                                                                                                                                             $dst_range = undef,
  Optional[Variant[Array[Pattern[/^(?:!\s)?(?:UNSPEC|UNICAST|LOCAL|BROADCAST|ANYCAST|MULTICAST|BLACKHOLE|UNREACHABLE|UNREACHABLE|PROHIBIT|THROW|NAT|XRESOLVE)(?:\s--limit-iface-(?:in|out))?$/]],
    Pattern[/^(?:!\s)?(?:UNSPEC|UNICAST|LOCAL|BROADCAST|ANYCAST|MULTICAST|BLACKHOLE|UNREACHABLE|UNREACHABLE|PROHIBIT|THROW|NAT|XRESOLVE)(?:\s--limit-iface-(?:in|out))?$/]]
  ]                                                                                                                                                                                               $dst_type = undef,
  Optional[Pattern[/^(\d+.\d+.\d+.\d+|\w+:\w+::\w+)$/]]                                                                                                                                           $gateway = undef,
  Optional[Variant[String[1], Integer]]                                                                                                                                                           $gid = undef,
  Optional[String[1]]                                                                                                                                                                             $goto = undef,
  Optional[Pattern[/^\d+(?:\/(?:sec|min|hour|day))?$/]]                                                                                                                                           $hashlimit_above = undef,
  Optional[Integer[1]]                                                                                                                                                                            $hashlimit_burst = undef,
  Optional[Integer[0,32]]                                                                                                                                                                         $hashlimit_dstmask = undef,
  Optional[Integer]                                                                                                                                                                               $hashlimit_htable_expire = undef,
  Optional[Integer]                                                                                                                                                                               $hashlimit_htable_gcinterval = undef,
  Optional[Integer]                                                                                                                                                                               $hashlimit_htable_max = undef,
  Optional[Integer]                                                                                                                                                                               $hashlimit_htable_size = undef,
  Optional[Pattern[/^(?:srcip|srcport|dstip|dstport)(?:\,(?:srcip|srcport|dstip|dstport))*$/]]                                                                                                    $hashlimit_mode = undef,
  Optional[String[1]]                                                                                                                                                                             $hashlimit_name = undef,
  Optional[Integer[0,32]]                                                                                                                                                                         $hashlimit_srcmask = undef,
  Optional[Pattern[/^\d+(?:\/(?:sec|min|hour|day))?$/]]                                                                                                                                           $hashlimit_upto = undef,
  Optional[String[1]]                                                                                                                                                                             $helper = undef,
  Optional[Variant[Pattern[/^(?:!\s)?\d+$/],Integer]]                                                                                                                                             $hop_limit = undef,
  Optional[Variant[String[1],Integer]]                                                                                                                                                            $icmp = undef,
  Optional[Pattern[/^(?:!\s)?[a-zA-Z0-9\-\._\+\:@]+$/]]                                                                                                                                           $iniface = undef,
  Optional[Enum['in', 'out']]                                                                                                                                                                     $ipsec_dir = undef,
  Optional[Enum['none', 'ipsec']]                                                                                                                                                                 $ipsec_policy = undef,
  Optional[Variant[Pattern[/^(?:!\s)?\w+\s(?:src|dst)(?:,src|,dst)?$/],Array[Pattern[/^(?:!\s)?\w+\s(?:src|dst)(?:,src|,dst)?$/]]]]                                                               $ipset = undef,
  Optional[Boolean]                                                                                                                                                                               $ipvs = undef,
  Optional[Boolean]                                                                                                                                                                               $isfirstfrag = undef,
  Optional[Boolean]                                                                                                                                                                               $isfragment = undef,
  Optional[Boolean]                                                                                                                                                                               $ishasmorefrags = undef,
  Optional[Boolean]                                                                                                                                                                               $islastfrag = undef,
  Optional[Boolean]                                                                                                                                                                               $kernel_timezone = undef,
  Optional[Pattern[/^([0-9]+)(:)?([0-9]+)?$/]]                                                                                                                                                    $length = undef,
  Optional[Pattern[/^\d+\/(?:sec(?:ond)?|min(?:ute)?|hour|day)$/]]                                                                                                                                $limit = undef,
  Optional[String[1]]                                                                                                                                                                             $line = undef,
  Optional[Boolean]                                                                                                                                                                               $log_ip_options = undef,
  Optional[Variant[Integer[0,7], String[1]]]                                                                                                                                                      $log_level = undef,
  Optional[String[1]]                                                                                                                                                                             $log_prefix = undef,
  Optional[Boolean]                                                                                                                                                                               $log_tcp_options = undef,
  Optional[Boolean]                                                                                                                                                                               $log_tcp_sequence = undef,
  Optional[Boolean]                                                                                                                                                                               $log_uid = undef,
  Optional[Pattern[/^(?:!\s)?([0-9a-fA-F]{2}[:]){5}([0-9a-fA-F]{2})$/]]                                                                                                                           $mac_source = undef,
  Optional[Pattern[/^\d+\.\d+\.\d+\.\d+$/]]                                                                                                                                                       $mask = undef,
  Optional[Pattern[/^(?:!\s)?[a-fA-F0-9x]+$/]]                                                                                                                                                    $match_mark = undef,
  Optional[Variant[Integer[0,31], Array[Integer[0,31]]]]                                                                                                                                          $month_days = undef,
  Optional[Pattern[/^(?:!\s)?\d+(?:\:\d+)?$/]]                                                                                                                                                    $mss = undef,
  Optional[Integer[1, 65535]]                                                                                                                                                                     $nflog_group = undef,
  Optional[String]                                                                                                                                                                                $nflog_prefix = undef,
  Optional[Integer[1]]                                                                                                                                                                            $nflog_range = undef,
  Optional[Integer[1]]                                                                                                                                                                            $nflog_size = undef,
  Optional[Integer[1]]                                                                                                                                                                            $nflog_threshold = undef,
  Optional[Boolean]                                                                                                                                                                               $notrack = undef,
  Optional[Pattern[/^(?:!\s)?[a-zA-Z0-9\-\._\+\:@]+$/]]                                                                                                                                           $outiface = undef,
  Optional[Pattern[/^(?:!\s)?[a-zA-Z0-9\-\._\+]+$/]]                                                                                                                                              $physdev_in = undef,
  Optional[Boolean]                                                                                                                                                                               $physdev_is_bridged = undef,
  Optional[Boolean]                                                                                                                                                                               $physdev_is_in = undef,
  Optional[Boolean]                                                                                                                                                                               $physdev_is_out = undef,
  Optional[Pattern[/^(?:!\s)?[a-zA-Z0-9\-\._\+]+$/]]                                                                                                                                              $physdev_out = undef,
  Optional[Enum['unicast', 'broadcast', 'multicast']]                                                                                                                                             $pkttype = undef,
  Optional[Pattern[/^(?:!\s)?(?:ip(?:encap)?|tcp|udp|icmp|esp|ah|vrrp|carp|igmp|ipv4|ospf|gre|cbt|sctp|pim|all)$/]]                                                                               $proto = undef,
  Optional[Boolean]                                                                                                                                                                               $queue_bypass = undef,
  Optional[Integer[1]]                                                                                                                                                                            $queue_num = undef,
  Optional[Boolean]                                                                                                                                                                               $random = undef,
  Optional[Boolean]                                                                                                                                                                               $random_fully = undef,
  Optional[Boolean]                                                                                                                                                                               $rdest = undef,
  Optional[Boolean]                                                                                                                                                                               $reap = undef,
  Optional[Enum['set', 'update', 'rcheck', 'remove', '! set', '! update', '! rcheck', '! remove']]                                                                                                $recent = undef,
  Optional[Enum['icmp-net-unreachable', 'icmp-host-unreachable', 'icmp6-addr-unreachable', 'addr-unreach', 'icmp6-port-unreachable']]                                                             $reject = undef,
  Optional[Integer[1]]                                                                                                                                                                            $rhitcount = undef,
  Optional[String[1]]                                                                                                                                                                             $rname = undef,
  Optional[Variant[Enum['loose', 'validmark', 'accept-local', 'invert']]]                                                                                                                         $rpfilter = undef,
  Optional[Integer[1]]                                                                                                                                                                            $rseconds = undef,
  Optional[Boolean]                                                                                                                                                                               $rsource = undef,
  Optional[Boolean]                                                                                                                                                                               $rttl = undef,
  Optional[String[1]]                                                                                                                                                                             $set_dscp = undef,
  Optional[Enum['af11', 'af12', 'af13', 'af21', 'af22', 'af23', 'af31', 'cs5', 'cs6', 'cs7', 'ef']]                                                                                               $set_dscp_class = undef,
  Optional[Pattern[/^[a-fA-F0-9x]+(?:\/[a-fA-F0-9x]+)?$/]]                                                                                                                                        $set_mark = undef,
  Optional[Integer[1]]                                                                                                                                                                            $set_mss = undef,
  Optional[Boolean]                                                                                                                                                                               $socket = undef,
  Optional[String[1]]                                                                                                                                                                             $source = undef,
  Optional[Variant[Array[Variant[Pattern[/^(?:!\s)?\d+(?:(?:\:|-)\d+)?$/], Integer]], Pattern[/^(?:!\s)?\d+(?:(?:\:|-)\d+)?$/], Integer]]                                                         $sport = undef,
  Optional[Pattern[/^[A-Z]{2}(,[A-Z]{2})*$/]]                                                                                                                                                     $src_cc = undef,
  Optional[String[1]]                                                                                                                                                                             $src_range = undef,
  Optional[Variant[Array[Pattern[/^(?:!\s)?(?:UNSPEC|UNICAST|LOCAL|BROADCAST|ANYCAST|MULTICAST|BLACKHOLE|UNREACHABLE|UNREACHABLE|PROHIBIT|THROW|NAT|XRESOLVE)(?:\s--limit-iface-(?:in|out))?$/]],
  Pattern[/^(?:!\s)?(?:UNSPEC|UNICAST|LOCAL|BROADCAST|ANYCAST|MULTICAST|BLACKHOLE|UNREACHABLE|UNREACHABLE|PROHIBIT|THROW|NAT|XRESOLVE)(?:\s--limit-iface-(?:in|out))?$/]]]                        $src_type = undef,
  Optional[Integer[1]]                                                                                                                                                                            $stat_every = undef,
  Optional[Enum['nth', 'random']]                                                                                                                                                                 $stat_mode = undef,
  Optional[Integer]                                                                                                                                                                               $stat_packet = undef,
  Optional[Variant[Integer[0,1], Float[0.0,1.0]]]                                                                                                                                                 $stat_probability = undef,
  Optional[Variant[Pattern[/^(?:!\s)?(?:INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED)$/], Array[Pattern[/^(?:!\s)?(?:INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED)$/]]]]                                $state = undef,
  Optional[String[1]]                                                                                                                                                                             $string = undef,
  Optional[Enum['bm', 'kmp']]                                                                                                                                                                     $string_algo = undef,
  Optional[Integer[1]]                                                                                                                                                                            $string_from = undef,
  Optional[Integer[1]]                                                                                                                                                                            $string_to = undef,
  Optional[Pattern[/^(?:!\s)?\|[a-zA-Z0-9\s]+\|$/]]                                                                                                                                               $string_hex = undef,
  Optional[Pattern[/^(?:!\s)?((FIN|SYN|RST|PSH|ACK|URG|ALL|NONE),?)+\s((FIN|SYN|RST|PSH|ACK|URG|ALL|NONE),?)+$/]]                                                                                 $tcp_flags = undef,
  Optional[Variant[Pattern[/^(?:!\s)?(?:[0-1][0-9]{0,2}|2[0-4][0-9]|25[0-5])$/], Integer[0,255]]]                                                                                                 $tcp_option = undef,
  Optional[Boolean]                                                                                                                                                                               $time_contiguous = undef,
  Optional[Pattern[/^([0-9]|[0-1][0-9]|2[0-3])\:[0-5][0-9](?:\:[0-5][0-9])?/]]                                                                                                                    $time_start = undef,
  Optional[Pattern[/^([0-9]|[0-1][0-9]|2[0-3])\:[0-5][0-9](?:\:[0-5][0-9])?/]]                                                                                                                    $time_stop = undef,
  Optional[String[1]]                                                                                                                                                                             $to = undef,
  Optional[String[1]]                                                                                                                                                                             $todest = undef,
  Optional[Pattern[/^\d+(?:-\d+)?$/]]                                                                                                                                                             $toports = undef,
  Optional[String[1]]                                                                                                                                                                             $tosource = undef,
  Optional[Pattern[/^0x[0-9a-fA-F]+&0x[0-9a-fA-F]+=0x[0-9a-fA-F]+(?::0x[0-9a-fA-F]+)?(?:&&0x[0-9a-fA-F]+&0x[0-9a-fA-F]+=0x[0-9a-fA-F]+(?::0x[0-9a-fA-F]+)?)*$/]]                                  $u32 = undef,
  Optional[Variant[String[1], Integer]]                                                                                                                                                           $uid = undef,
  Optional[Variant[Enum['Mon','Tue','Wed','Thu','Fri','Sat','Sun'], Array[Enum['Mon','Tue','Wed','Thu','Fri','Sat','Sun']]]]                                                                      $week_days = undef,
  Optional[Integer]                                                                                                                                                                               $zone = undef,
) {
  #lint:endignore
  $firewall_params = {
    'ensure' => $ensure,
    'chain' => $chain,
    'table' => $table,
    'protocol' => $protocol,
    'clusterip_clustermac' => $clusterip_clustermac,
    'action' => $action,
    'burst' => $burst,
    'bytecode' => $bytecode,
    'cgroup' => $cgroup,
    'checksum_fill' => $checksum_fill,
    'clamp_mss_to_pmtu' => $clamp_mss_to_pmtu,
    'clusterip_hash_init' => $clusterip_hash_init,
    'clusterip_hashmode' => $clusterip_hashmode,
    'clusterip_local_node' => $clusterip_local_node,
    'clusterip_new' => $clusterip_new,
    'clusterip_total_nodes' => $clusterip_total_nodes,
    'condition' => $condition,
    'connlimit_above' => $connlimit_above,
    'connlimit_mask' => $connlimit_mask,
    'connlimint_upto' => $connlimit_upto,
    'connmark' => $connmark,
    'ctdir' => $ctdir,
    'ctexpire' => $ctexpire,
    'ctorigdst' => $ctorigdst,
    'ctorigdstport' => $ctorigdstport,
    'ctorigsrc' => $ctorigsrc,
    'ctorigsrcport' => $ctorigsrcport,
    'ctproto' => $ctproto,
    'ctrepldst' => $ctrepldst,
    'ctrepldstport' => $ctrepldstport,
    'ctreplsrc' => $ctreplsrc,
    'ctreplsrcport' => $ctreplsrcport,
    'ctstate' => $ctstate,
    'ctstatus' => $ctstatus,
    'date_start' => $date_start,
    'date_stop' => $date_stop,
    'destination' => $destination,
    'dport' => $dport,
    'dst_cc' => $dst_cc,
    'dst_range' => $dst_range,
    'dst_type' => $dst_type,
    'gateway' => $gateway,
    'gid' => $gid,
    'goto' => $goto,
    'hashlimit_above' => $hashlimit_above,
    'hashlimit_burst' => $hashlimit_burst,
    'hashlimit_dstmask' => $hashlimit_dstmask,
    'hashlimit_htable_expire' => $hashlimit_htable_expire,
    'hashlimit_htable_gcinterval' => $hashlimit_htable_gcinterval,
    'hashlimit_htable_max' => $hashlimit_htable_max,
    'hashlimit_htable_size' => $hashlimit_htable_size,
    'hashlimit_mode' => $hashlimit_mode,
    'hashlimit_name' => $hashlimit_name,
    'hashlimit_srcmask' => $hashlimit_srcmask,
    'hashlimit_upto' => $hashlimit_upto,
    'helper' => $helper,
    'hop_limit' => $hop_limit,
    'icmp' => $icmp,
    'iniface' => $iniface,
    'ipsec_dir' => $ipsec_dir,
    'ipsec_policy' => $ipsec_policy,
    'ipset' => $ipset,
    'ipvs' => $ipvs,
    'isfirstfrag' => $isfirstfrag,
    'isfragment' => $isfragment,
    'ishasmorefrags' => $ishasmorefrags,
    'islastfrag' => $islastfrag,
    'kernel_timezone' => $kernel_timezone,
    'length' => $length,
    'limit' => $limit,
    'line' => $line,
    'log_ip_options' => $log_ip_options,
    'log_level' => $log_level,
    'log_prefix' => $log_prefix,
    'log_tcp_options' => $log_tcp_options,
    'log_tcp_sequence' => $log_tcp_sequence,
    'log_uid' => $log_uid,
    'mac_source' => $mac_source,
    'mask' => $mask,
    'match_mark' => $match_mark,
    'month_days' => $month_days,
    'mss' => $mss,
    'nflog_group' => $nflog_group,
    'nflog_prefix' => $nflog_prefix,
    'nflog_range' => $nflog_range,
    'nflog_size' => $nflog_size,
    'nflog_threshold' => $nflog_threshold,
    'notrack' => $notrack,
    'outiface' => $outiface,
    'physdev_in' => $physdev_in,
    'physdev_is_bridged' => $physdev_is_bridged,
    'physdev_is_in' => $physdev_is_in,
    'physdev_is_out' => $physdev_is_out,
    'physdev_out' => $physdev_out,
    'pkttype' => $pkttype,
    'proto' => $proto,
    'queue_bypass' => $queue_bypass,
    'queue_num' => $queue_num,
    'random' => $random,
    'random_fully' => $random_fully,
    'rdest' => $rdest,
    'reap' => $reap,
    'recent' => $recent,
    'reject' => $reject,
    'rhitcount' => $rhitcount,
    'rname' => $rname,
    'rpfilter' => $rpfilter,
    'rseconds' => $rseconds,
    'rsource' => $rsource,
    'rttl' => $rttl,
    'set_dscp' => $set_dscp,
    'set_dscp_class' => $set_dscp_class,
    'set_mark' => $set_mark,
    'set_mss' => $set_mss,
    'socket' => $socket,
    'source' => $source,
    'sport' => $sport,
    'src_cc' => $src_cc,
    'src_range' => $src_range,
    'src_type' => $src_type,
    'stat_every' => $stat_every,
    'stat_mode' => $stat_mode,
    'stat_packet' => $stat_packet,
    'stat_probability' => $stat_probability,
    'state' => $state,
    'string' => $string,
    'string_algo' => $string_algo,
    'string_from' => $string_from,
    'string_to' => $string_to,
    'string_hex' => $string_hex,
    'tcp_flags' => $tcp_flags,
    'tcp_option' => $tcp_option,
    'time_contiguous' => $time_contiguous,
    'time_start' => $time_start,
    'time_stop' => $time_stop,
    'to' => $to,
    'todest' => $todest,
    'toports' => $toports,
    'tosource' => $tosource,
    'u32' => $u32,
    'uid' => $uid,
    'week_days' => $week_days,
    'zone' => $zone,
  }

  multiwall::$target_firewall::rule { $name:
    params => $firewall_params,
  }
}
